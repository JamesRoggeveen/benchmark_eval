import sympy as sp
from sympy.parsing.sympy_parser import standard_transformations, implicit_multiplication_application, convert_xor, implicit_application
import os
import regex as re
import numpy as np
import argparse
from typing import List, Tuple, Optional, Dict, Any
from dataclasses import dataclass, field

# Base error class - not using dataclass for the base class
class ParseError(Exception):
    """Base class for all parsing related errors"""
    def __init__(self, message: str, original_error: Optional[Exception] = None):
        super().__init__(message)
        self.message = message
        self.original_error = original_error

    def __str__(self) -> str:
        return self.message

# Simple error types as regular classes
class SolutionExtractionError(ParseError):
    """Raised when unable to extract solution from boxed environment"""
    def __init__(self, message: str, original_error: Optional[Exception] = None):
        super().__init__(message, original_error)

class LatexConversionError(ParseError):
    """Raised when unable to convert LaTeX to a standard expression"""
    def __init__(self, message: str, latex: str, rule: Optional[str] = None, 
                 original_error: Optional[Exception] = None):
        super().__init__(message, original_error)
        self.latex = latex
        self.rule = rule

class SymPyConversionError(ParseError):
    """Raised when unable to convert expression to SymPy"""
    def __init__(self, message: str, expression: str, stage: str, 
                 original_error: Optional[Exception] = None):
        super().__init__(message, original_error)
        self.expression = expression
        self.stage = stage

class EvaluationError(ParseError):
    """Raised when unable to evaluate a SymPy expression"""
    def __init__(self, message: str, expression: Any, parameters: Optional[Dict] = None,
                 original_error: Optional[Exception] = None):
        super().__init__(message, original_error)
        self.expression = expression
        self.parameters = parameters

def extract_solution(solution_string: str) -> List[str]:
    """Searches LLM response for boxed solution and returns it.

    Searches through output generated by LLM in response to a given problem and
    extracts the boxed answer.

    Args:
        solution_string: String containing LaTeX solution

    Returns:
        List of extracted solution strings

    Raises:
        SolutionExtractionError: If no boxed solution is found or format is invalid
    """
    try:
        solution_group = re.search(r'boxed\{(.*)\}', solution_string)
        if not solution_group:
            raise SolutionExtractionError("No boxed solution found in response")
        
        solution = solution_group.group(1)
        if not solution.strip():
            raise SolutionExtractionError("Empty solution found in boxed environment")
            
        solution_list = solution.split(';')
        solution_list = [s.strip() for s in solution_list]
        
        # Validate each solution part
        for i, part in enumerate(solution_list):
            if not part:
                raise SolutionExtractionError(f"Empty solution part found at index {i}")
                
        return solution_list
    except re.error as e:
        raise SolutionExtractionError(f"Regex error while extracting solution: {str(e)}", e)
    except Exception as e:
        raise SolutionExtractionError(f"Unexpected error while extracting solution: {str(e)}", e)

# This should probably not be a dictionary as order of rule application matters
replacement_rules = {
    r'\\approx': r'=',                                  # replace all forms of approximate equals
    r'\\sim': r'=',
    r'\\pm': r'',                                       # rewrite plus or minus to take positive branch (FIX LATER)
    r'\\left': r'',                                     # delete latex formatting
    r'\\right': r'',
    r'\\sqrt\[(\d+?)\]\{(.*?)\}': r'(\1)^(1/(\2))',     # rewrite fractional powers that were expressed using \sqrt fn
    r'\\frac\{(.*?)\}\{(.*?)\}': r'((\1)/(\2))',        # rewrite \frac functions
    r'(?<![a-zA-Z])e(?![a-zA-Z])': r'E',
    r'\\Gamma\((.*?)\)': r'gamma(\1)',
    r'_\{(.*?)\}': r'\1',                               # for variable identification, rewrite all underscores
    r'\{': r'(',                                        # remove bracket formatting
    r'\}': r')',
    r'\\sin(?!\s)': r'sin ',                           # handle trig functions separately
    r'\\cos(?!\s)': r'cos ',
    r'\\tan(?!\s)': r'tan ',
    r'\\csc(?!\s)': r'csc ',
    r'\\sec(?!\s)': r'sec ',
    r'\\cot(?!\s)': r'cot ',
    r'(sin|cos|tan|csc|sec|cot)(?!\s)': r'\1 ',        # ensure space after any trig function
    r'\\': r''                                          # remove remaining escape characters
}

def latex_to_expression(latex_string: str) -> str:
    """Applies replacement rules to a LaTeX expression.

    Converts a string containing a LaTeX math expression into one compatible
    with sympy's parse_expr function by applying a custom set of replacement rules.

    Args:
        latex_string: String containing LaTeX math

    Returns:
        String containing converted expression

    Raises:
        LatexConversionError: If conversion fails at any step
    """
    if not latex_string or not latex_string.strip():
        raise LatexConversionError("Empty LaTeX string provided", latex_string)
        
    try:
        print(f"Original latex: {latex_string}")  # Debug log
        current_string = latex_string
        
        for pattern, replacement in replacement_rules.items():
            try:
                old_string = current_string
                current_string = re.sub(pattern, replacement, current_string)
                if old_string != current_string:
                    print(f"Rule {pattern} -> {replacement}")  # Debug log
                    print(f"Changed to: {current_string}")  # Debug log
            except re.error as e:
                raise LatexConversionError(
                    f"Failed to apply replacement rule: {str(e)}", 
                    latex_string, 
                    pattern,
                    e
                )
                
        if not current_string.strip():
            raise LatexConversionError(
                "Conversion resulted in empty string", 
                latex_string
            )
            
        return current_string
        
    except Exception as e:
        if not isinstance(e, LatexConversionError):
            raise LatexConversionError(
                f"Unexpected error during LaTeX conversion: {str(e)}", 
                latex_string,
                None,
                e
            )
        raise

def expression_to_sympy(expr_string: str) -> sp.Expr:
    """Converts an expression string to a sympy expression.

    Uses sympy's parse_expr function to convert a string containing a mathematical
    expression into a sympy expression object. Uses sympy transformation functions
    to handle certain inputs without requiring use of custom rules.

    Args:
        expr_string: String containing mathematical expression

    Returns:
        SymPy expression object

    Raises:
        SymPyConversionError: If conversion fails at any stage
    """
    if not expr_string or not expr_string.strip():
        raise SymPyConversionError("Empty expression provided", expr_string, "input_validation")
        
    try:
        # Handle equals sign
        if "=" in expr_string:
            parts = expr_string.split("=")
            if len(parts) > 2:
                raise SymPyConversionError(
                    "Multiple equals signs found", 
                    expr_string, 
                    "equals_handling"
                )
            expr_string = parts[1].strip()
            
        # Handle comma
        if ',' in expr_string:
            parts = expr_string.split(',')
            if len(parts) > 2:
                raise SymPyConversionError(
                    "Multiple commas found", 
                    expr_string, 
                    "comma_handling"
                )
            expr_string = parts[0].strip()
            
        if not expr_string:
            raise SymPyConversionError(
                "Expression is empty after splitting", 
                expr_string, 
                "post_split"
            )
        
        print(f"Expression before SymPy parsing: {expr_string}")  # Debug log
            
        # Parse expression
        transformations = (standard_transformations + 
                         (implicit_multiplication_application,
                          convert_xor,
                          implicit_application))
        try:
            expr = sp.parsing.parse_expr(expr_string, transformations=transformations)
            print(f"Successfully parsed to SymPy: {expr}")  # Debug log
            return expr
        except Exception as e:
            raise SymPyConversionError(
                f"SymPy parsing error: {str(e)}", 
                expr_string, 
                "sympy_parsing",
                e
            )
            
    except Exception as e:
        if not isinstance(e, SymPyConversionError):
            raise SymPyConversionError(
                f"Unexpected error during conversion: {str(e)}", 
                expr_string, 
                "unknown",
                e
            )
        raise

def solution_to_sympy(solution_string: str) -> Tuple[Optional[List[sp.Expr]], str, Optional[List[str]], Optional[List[str]]]:
    """Converts solution string to sympy expression.

    Takes an LLM solution to a given math problem, extracts the boxed answer,
    converts it to a sympy expression using the latex_to_expression and
    expression_to_sympy functions.

    Args:
        solution_string: String containing complete solution with boxed answer

    Returns:
        Tuple containing:
        - List of SymPy expressions or None if conversion failed
        - Error message string (empty if successful)
        - List of extracted solution strings or None if extraction failed
        - List of intermediate expressions or None if conversion failed
    """
    try:
        # Extract solution from boxed environment
        extracted_solution = extract_solution(solution_string)
        
        # Convert LaTeX to standard expressions
        solution_expr_list = [latex_to_expression(s) for s in extracted_solution]
        
        # Convert to SymPy expressions
        solution_sympy_list = [expression_to_sympy(s) for s in solution_expr_list]
        
        return solution_sympy_list, "", extracted_solution, solution_expr_list
        
    except ParseError as e:
        return None, str(e), None, None
    except Exception as e:
        return None, f"Unexpected error: {str(e)}", None, None

def evaluate_sympy_solution(sympy_solution: sp.Expr, t: float) -> np.float32:
    """Evaluates sympy expression at given value of t.

    Given a sympy expression written for the variable x, evaluates the expression
    at the given value of x=t and returns the result as a numpy float32.

    Args:
        sympy_solution: SymPy expression to evaluate
        t: Value to substitute for x

    Returns:
        Result as numpy float32

    Raises:
        EvaluationError: If evaluation fails
    """
    try:
        x = sp.symbols('x')
        result = sympy_solution.subs(x, t).evalf()
        return np.array(float(result), dtype=np.float32)
    except Exception as e:
        raise EvaluationError(
            f"Failed to evaluate expression: {str(e)}", 
            sympy_solution,
            {'x': t},
            e
        )

def evaluate_solution_with_parameters(
    solution_str: str,
    parameter_str: str
) -> Tuple[Optional[List[Any]], str, Optional[List[str]]]:
    """Evaluates solution with given parameters.
    
    Args:
        solution_str: String containing solution with boxed answer
        parameter_str: String containing parameter definitions
        
    Returns:
        Tuple containing:
        - List of evaluation results or None if evaluation failed
        - Error message string (empty if successful)
        - List of intermediate expressions or None if conversion failed
    """
    try:
        # Convert solution to SymPy
        sympy_expr, error_message, extracted_solution, solution_expr_list = solution_to_sympy(solution_str)
        if error_message:
            return None, error_message, solution_expr_list
            
        # Clean and parse parameters
        parameter_list = parameter_str.replace("$","").replace(" ","").replace("\\","").split(",")
        vars = [sp.symbols(p) for p in parameter_list]
        
        # Use fixed seed for reproducibility
        np.random.seed(42)
        parameter_dict = {var: np.random.uniform(1,2) for var in vars}
        np.random.seed(None)  # Reset seed
        
        # Evaluate expressions
        results = []
        for expr in sympy_expr:
            try:
                result = expr.subs(parameter_dict).evalf()
                results.append(result)
            except Exception as e:
                raise EvaluationError(
                    f"Failed to evaluate expression: {str(e)}", 
                    expr,
                    parameter_dict,
                    e
                )
                
        return results, "", solution_expr_list
        
    except ParseError as e:
        return None, str(e), None
    except Exception as e:
        return None, f"Unexpected error: {str(e)}", None

if __name__ == "__main__":
    # Set up argument parser
    parser = argparse.ArgumentParser(description='Parse and evaluate LaTeX expressions')
    parser.add_argument('expression', type=str, help='LaTeX expression to evaluate')
    parser.add_argument('--t', type=float, default=2.0, 
                       help='Value of x to evaluate expression at (default: 2.0)')
    
    args = parser.parse_args()
    
    try:
        # Convert the LaTeX expression to sympy and evaluate
        sympy_expr, error_message, extracted_solution, solution_expr_list = solution_to_sympy(args.expression)
        if error_message:
            print(f"Error: {error_message}")
            exit(1)
            
        result = evaluate_sympy_solution(sympy_expr[0], args.t)
        print(f"Result at x = {args.t}: {result}")
        
    except ParseError as e:
        print(f"Error: {str(e)}")
        if hasattr(e, 'stage'):
            print(f"Failed at stage: {e.stage}")
        if hasattr(e, 'expression'):
            print(f"Problematic expression: {e.expression}")
        exit(1)
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        exit(1)